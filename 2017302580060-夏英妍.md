﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿# Assignment 4### p30101 0101 + 0111 0000 = 1100 01011100 0101 + 0100 1100 = 0001 0001二进制反码为：1110 1110检测错误,接收方添加四个字(原来的三个单词和校验和)。如果和包含一个0,接收方知道存在一个错误。1比特的差错可以被检测出来，但2比特的差错无法检测(例如,如果第一个单词最后的数字转换为0,第二个词的最后数字转换为1)。### p18a. Here we have a window size of N=3. Suppose the receiver has received packet k-1, and has ACKed that and all other preceeding packets. If all of these ACK’s have been received by sender, then sender’s window is [k, k+N-1]. Suppose next that none of the ACKs have been received at the sender. In this second case, the sender’s window contains k-1 and the N packets up to and including k-1. The sender’s window is thus [k-N,k-1]. By these arguments, the senders window is of size 3 and begins somewhere in the range [k-N,k].b. If the receiver is waiting for packet k, then it has received (and ACKed) packet k-1 and the N-1 packets before that. If none of those N ACKs have been yet received by the sender, then ACK messages with values of [k-N,k-1] may still be propagating back.Because the sender has sent packets [k-N, k-1], it must be the case that the sender has already received an ACK for k-N-1. Once the receiver has sent an ACK for k-N-1 it will never send an ACK that is less that k-N-1. Thus the range of in-flight ACK values can range from k-N-1 ~ k-1.###udpThis is the [ link](https://github.com/Choco-x/homework/blob/master/udp_check.py). 